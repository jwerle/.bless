#!/usr/bin/env bash

function die () {
	declare local message=$1
	declare -i local code=$2

	[ "$message" ] && echo $message;
	if ! [[ -z "$code" ]]; then
		exit $code
	else
		exit 0
	fi
}

function fatal () {
	die "$1" 1
}

function hasInternalCommand () {
	if command -v $1 >/dev/null 2>&1; then true;
	else false;
	fi
}

function hasFlag () {
	declare local found=false
	if ! [ "${1:0:1}" = "-" ]; then
		declare local flag="--${1}"
	else
		declare local flag="${1}"
	fi

	for arg in ${BLESS_ARGS[@]}; do
		if [ "$arg" = "$flag" ]; then found=true; fi
	done
	$found
}

function hasCommand () {
	declare local found=false
	for arg in ${BLESS_ARGS[@]}; do
		if [ "$arg" = "$1" ]; then found=true; fi
	done
	$found
}

function flagValue () {
	local flag value found
	flag="--$1"
	found=false
	for arg in ${BLESS_ARGS[@]}; do
		if $found; then
			echo $arg;
			break;
		fi

		if [ "$arg" = "$flag" ]; then
			found=true;
		fi
	done
}

function getRequirements () {
	local commands
	declare -a commands=("git" "ruby" "node" "npm")
	echo ${commands[@]}
}

function checkPrereqs () {	
	local commands
	commands=$(getRequirements)
	for command in ${commands[@]}; do
		if ! command -v $command >/dev/null 2>&1; then
			echo "Missing '$command' from system. Please install to use Bless.";
			exit 1
		fi
	done
}


function getSupportedProfiles () {
	local profiles
	# supported profile
	declare -a profiles=(".bashrc" ".bash_profile" ".profile")
	echo "${profiles[@]}"
}

function isProfileSupported () {
	for profile in ${profiles[@]}; do
		if [ "$1" = "$profile" ]; then
			true
			break;
		fi
	done

	false
}


##
# Usage construct
# @param {string} $1 command
# @param {array} $2 commands
# @param {array} $3 flags
##
function Usage () {
	## variables
	local usage
	declare local command=$1
	declare -a local commands=(${!2})
	declare -a local flags=(${!3})
	declare local hasParent=$4
	declare local parent=''

	if $hasParent && [ "$command" != "dotbless" ]; then
		parent="$command "
	fi
	echo
	printf "  Usage: $command "

	[ "${#commands[@]}" != "0" ] && printf "[command] ";
	[ "${#flags[@]}" != "0" ] && printf "[options]";
	echo

	## if we have commmands lets show them
	if [ "${#commands[@]}" != "0" ]; then
		echo
		echo "  Commands:"
		echo
		# output commands and there usage
		for command in ${commands[@]}; do
			declare usage="$(dotbless $parent $command --usage)"
			echo "    $command 	$usage"
		done
	fi

	## if we have options lets show them
	if [ "${#flags[@]}" != "0" ]; then
		echo
		echo "  Options:"
		# output flags and there purpose
		for flag in ${flags[@]}; do
			if [ "$flag" != "--completions" ]; then
				echo "    $flag	$(flagsUsage $flag)";
			fi
		done
	fi
}


function commandFromPath () {
	echo $(echo "$1" | tr "/" " ")
}

function lastCommand () {
	declare -a local commands=(${!1})
	declare -a local clean=()
	declare -i local offset=1

	if ! [[ -z $2 ]]; then
		offset=$2
	fi

	for command in ${commands[@]}; do
		if [ ${command:0:1} != "-" ]; then
			clean+=($command)
		fi
	done

	

	if [ $(expr ${#clean[@]} - $offset) -lt 0 ]; then
		offset=0
	fi

	#echo "o"$(expr ${#clean[@]} - $offset)
	#echo "l"${#clean[@]}
	echo ${clean[ $(expr ${#clean[@]} - $offset) ]}
}

function getArgs () {
	local value found
	found=false
	declare -a args=( ${BLESS_ARGS[@]} )
	declare -a clean=()
	declare -i len=${#args[@]}

	for (( i = 0; i < $len; i++ )); do
		if [ "${args[$i]}" = "$1" ]; then break; fi
	done
	echo ${args[@]:$(expr $i + 1)}
}

function requestingHelp () {
	if hasFlag "help" || hasCommand "help" || hasFlag "-h"; then true
	else false
	fi
}

function stringToArray () {
	read -a array <<< "$1"
	echo "${array[@]}"
}

function invalidCommand () {
	declare local command=$1
	declare local type=$2

	if [[ -z "$type" ]]; then
		type="command"
	fi

	echo "dotbless: '${command}' is not a dotbless ${type}. See 'dotbless --help'".
}

function inArray () {
	declare -a local array=$1
	echo ${1}
	declare local needle="$2"
	for item in  ${array[@]}; do
		echo $item
		echo $needle
	done
}

function lastElement () {
	local foo="$1"
	declare -a local array=("${!1}")
	echo ${array[ $(expr ${#array[@]} - 1) ]}
}


function resolveProfileConf () {
	declare local profile="$1"
	if test -f "$BLESS_DIR/profiles/$profile/$profile.conf"; then
		echo "$BLESS_DIR/profiles/$profile/$profile.conf"
	elif test -f "$BLESS_DIR/profiles/$profile/$profile.ini"; then
		echo "$BLESS_DIR/profiles/$profile/$profile.ini"
	else
		false
	fi
}

## 
# CFG INI Parser
# @see http://ajdiaz.wordpress.com/2008/02/09/bash-ini-parser/
##
function bless.IniParser ()
{
  ini="$(<$1)"                # read the file
  ini="${ini//[/\[}"          # escape [
  ini="${ini//]/\]}"          # escape ]
  IFS=$'\n' && ini=( ${ini} ) # convert to line-array
  ini=( ${ini[*]//;*/} )      # remove comments with ;
  ini=( ${ini[*]/\    =/=} )  # remove tabs before =
  ini=( ${ini[*]/=\   /=} )   # remove tabs be =
  ini=( ${ini[*]/\ =\ /=} )   # remove anything with a space around =
  ini=( ${ini[*]/#\\[/\}$'\n'bless.section.} ) # set section prefix
  ini=( ${ini[*]/%\\]/ \(} )    # convert text2function (1)
  ini=( ${ini[*]/=/=\( } )    # convert item to array
  ini=( ${ini[*]/%/ \)} )     # close array parenthesis
  ini=( ${ini[*]/%\\ \)/ \\} ) # the multiline trick
  ini=( ${ini[*]/%\( \)/\(\) \{} ) # convert text2function (2)
  ini=( ${ini[*]/%\} \)/\}} ) # remove extra parenthesis
  ini[0]="" # remove first element
  ini[${#ini[*]} + 1]='}'    # add the last brace
  #echo "${ini[*]}" # eval the result
  eval "$(echo "${ini[*]}")" # eval the result
}
 
function bless.IniWriter ()
{
  IFS=' '$'\n'
  fun="$(declare -F)"
  fun="${fun//declare -f/}"
  for f in $fun; do
      [ "${f#bless.section}" == "${f}" ] && continue
      item="$(declare -f ${f})"
      item="${item##*\{}"
      item="${item%\}}"
      item="${item//=*;/}"
      vars="${item//=*/}"
      eval $f
      echo "[${f#bless.section.}]"
      for var in $vars; do
          echo $var=\"${!var}\"
      done
  done
}

# bless.parser "${BLESS_DIR}/test/sample.ini"

# bless.section.alias
# echo $name
# exit;